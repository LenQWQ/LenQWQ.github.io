---
title: 洛谷P14246
date: 2025-12-11 21:34:03
tags:
---

## #[luogu P14246]([P14246 [CCPC 2024 Shandong I\] 多彩的生成树 - 洛谷](https://www.luogu.com.cn/problem/P14246))

## 大致思路

算是 *Kruskal* 的模板题，先从每个颜色的 *N* 个结点中找出一个点，把这些点用 *Kruskal* 算法连接起来，用 *ans* 来存储操作后的结果，此时每个颜色就只剩下 *N*−1 个结点，这时候只需要找出链接哪个颜色的边权最小，将剩下的 *N*−1 个结点乘以这个权值加到 *ans* 中，那么 *ans* 就是最小的总权值。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 10000;
const int M = 1e6+2;
int a[M];
int con[M];
int val[N][N];
int find(int k){
    if(k == a[k]) return k;
    return a[k] = find(a[k]); //并查集模板
}
struct node{
    int u,v,w;
    bool operator < (const node &o) const{
        return (o.w > w); //小顶堆
    }
};
vector<node>edge;
void add_edge(int u,int v,int w){
    edge.push_back({u,v,w}); //边的存储函数
    return;
}
int main(){
    int T;cin >> T;
    while(T--){
        edge.clear();//每次循环前把边集清空
        int n;cin >> n;
        for(int i=1;i<=n;i++) a[i] = i;
        for(int i=1;i<=n;i++) cin >> con[i]; //存储每个颜色的结点个数
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                cin >> val[i][j];
                if(j == i) continue;
                add_edge(i,j,val[i][j]);//存储边的信息
            }
        }
        long long ans = 0,connect = 0;
        sort(edge.begin(),edge.end());
        for(int i=0;i<(int)edge.size() && connect < n-1;i++){
            int x = find(edge[i].u),y = find(edge[i].v);
            if(x != y){
                a[x] = y;
                ans += edge[i].w;
                connect++;
            }else{
                continue;
            }
        } // 最小生成树模板
        for(int i=1;i<=n;i++){
            int min_ = *min_element(val[i]+1,val[i]+1+n);
            ans += (long long)min_*(con[i]-1); // 找出链接哪个颜色的边权最小，记得一定要开longlong，不然会爆
        }
        cout << ans << endl;
    }
    return 0;
}

```

